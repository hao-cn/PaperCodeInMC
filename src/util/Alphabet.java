package util;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * author: Hao 
 * date:Jan 21, 2016
 * time:3:58:24 PM
 * purpose:
 */
public class Alphabet {
	private Map<BitSet, Element> map;
	private Map<Integer, HashSet<Element>> inverseIndex;
	private Map<Integer, HashSet<Element>> sourceIndex;
	private List<Element> heuristicList;
	
	public Alphabet() {
		this.map = new HashMap<>();
		this.inverseIndex = new HashMap<>();
		this.heuristicList = new ArrayList<>();
	}
	
	/**
	 * add new natural element into alphabet
	 */
	public void addNaturalElement(Element addOne){
		map.put(addOne.getValue().getClosure(), addOne);

		buildSourceIndex(addOne);
		buildInverseIndex(addOne);
		heuristicList.add(addOne);
	}
	
	/**
	 * add new element which is generated by two elements
	 */
	public void addElement(Element addOne){
		map.put(addOne.getValue().getClosure(), addOne);
		
		buildInverseIndex(addOne);
		heuristicList.add(addOne);
	}
	
	/**
	 * build the inverse index, in order to reduce the time cost of later process
	 */
	private void buildInverseIndex(Element addOne) {
		 for (int i = addOne.getValue().getClosure().nextSetBit(0); i >= 0; i = addOne.getValue().getClosure().nextSetBit(i+1)) {
		     Integer key = new Integer(i);
		     HashSet<Element> set = inverseIndex.get(key);
		     if(set == null){
		    	 set = new HashSet<>();
		    	 inverseIndex.put(key, set);
		     }
		     set.add(addOne);
		 }
	}
	
	/**
	 * build the source index, in order to reduce the time cost of update elements
	 */
	private void buildSourceIndex(Element addOne) {
		 for (int i = addOne.getValue().getClosure().nextSetBit(0); i >= 0; i = addOne.getValue().getClosure().nextSetBit(i+1)) {
		     Integer key = new Integer(i);
		     HashSet<Element> set = sourceIndex.get(key);
		     if(set == null){
		    	 set = new HashSet<>();
		    	 sourceIndex.put(key, set);
		     }
		     set.add(addOne);
		 }
	}
	
	/**
	 * build heuristic List
	 * since use the new feature in Java8, the require JDK 1.8
	 */
	public void buildHeuristicListJ18(){
		/** at first, calculate the posSup, negSup and cRatio **/
		heuristicList.stream().forEach(new Consumer<Element>() {
			@Override
			public void accept(Element t) {
				t.calculate();
			}
		});
		
		/** sort the heuristic List **/
		ElementComparator ec = new ElementComparator();
		Collections.sort(heuristicList, ec);
	}

	
	/************************************************
	 * Getter and Setter
	 ************************************************/
	public Element getElementByBitSet(BitSet bs){
		return map.get(bs);
	}
	
	public Map<BitSet, Element> getMap() {
		return map;
	}

	public void setMap(HashMap<BitSet, Element> map) {
		this.map = map;
	}

	public Map<Integer, HashSet<Element>> getInverseIndex() {
		return inverseIndex;
	}

	public void setInverseIndex(HashMap<Integer, HashSet<Element>> inverseIndex) {
		this.inverseIndex = inverseIndex;
	}

	public List<Element> getHeuristicList() {
		return heuristicList;
	}

	public void setHeuristicList(ArrayList<Element> heuristicList) {
		this.heuristicList = heuristicList;
	}
	
}
